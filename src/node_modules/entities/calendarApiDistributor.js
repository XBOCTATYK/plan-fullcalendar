import moment from "moment";

export class CalendarApiDistributor {
    static _apiCollection = {};
    static _apiCounter = 0;

    static addApi(api, name = `api_${this._apiCounter}`) {

        if (!api instanceof CalendarApiItem) throw new Error('Ты мне передаешь какую то дичь! Здесь должен быть объект типа CalendarApiItem');

        this._apiCollection[name] = api;
        return name;
    }

    static removeApi(name) {
        const removingApi = Object.assign({}, this._apiCollection[name]);
        delete this._apiCollection[name];

        return removingApi;
    }

    static getInstance() {
        return this;
    }

    constructor() {
        return null;
    }

}

export class CalendarApiItem {
    _api = null;

    constructor(apiObject) {
        if (this._api) {
            console.warn('Calendar Api already has in this instance.')
        }

        this._api = apiObject;
    }

    addItem(params) {
        if (!this._api) return;

        this._api.addEvent(params);
    }

    removeItem(id) {
        if (!this._api) return;

        const eventToRemove = this._api.getEventById(id);
        eventToRemove.remove();
    }

    changeItem(id, params) {
        if (!this._api) return;

        const eventToChange = this._api.getEventById(id);

        params.start = eventToChange.start;
        params.end = moment(params.start).add(params.time, 'm').format();

        for (let key in params) {
            if (!Object.prototype.hasOwnProperty.call(params, key)) return;

            switch (key) {
                case 'start':
                    eventToChange.setStart(params[key]);
                    break;
                case 'end':
                    eventToChange.setEnd(params[key]);
                    break;
                default:
                    eventToChange.setProp(key, params[key])
            }
        }
    }
}
